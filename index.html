<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     yzqaq
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="yzqaq" type="application/atom+xml">
</head>

</html>

<body>
  
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">yzqaq</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-about" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/26/about/"
    >About Me</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/about/" class="article-date">
  <time datetime="2020-05-26T13:37:04.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>GitHub: <a href="https://github.com/yzqaq" target="_blank" rel="noopener">Shen-Yu</a><br>mail: <a href="mailto:abloibce@qq.com">abloibce@qq.com</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-blog/sort" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/26/blog/sort/"
    >十大排序</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/blog/sort/" class="article-date">
  <time datetime="2020-05-26T05:26:02.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="图解十大经典排序"><a href="#图解十大经典排序" class="headerlink" title="图解十大经典排序"></a>图解十大经典排序</h1><p><img src="img/sort0.jpg" alt=""><br>注：n表示数据规模，k表示桶的个数，In-place表示占用常数内存或不占用额外内存，Out-place表示占用额外内存。什么是稳定性？当排序后2个相等键值的顺序 和 排序前它们的顺序相同，则表示“稳定”。</p>
<h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><p><img src="img/2463290-759e8a17f2f8fe49.gif" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序 改进</span></span><br><span class="line"><span class="comment"> * 置一个标志位，记录最后换位置的位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSortPro</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> point = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        point = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">                point = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = a.length - point - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><p><img src="img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[minIndex];</span><br><span class="line">            a[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3 插入排序"></a>3 插入排序</h2>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8A%9D%E5%A3%AB/" rel="tag">芝士</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-blog/洗牌算法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/26/blog/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"
    >洗牌算法</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/blog/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-05-26T05:26:02.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>Fisher-Yates shuffle</strong> 算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将最后一个数和前面任意n-1个数中的一个数进行交换，然后倒数第二个数和前面任意n-2个数的一个数进行交换，以此类推.</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8A%9D%E5%A3%AB/" rel="tag">芝士</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-blog/美团" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/26/blog/%E7%BE%8E%E5%9B%A2/"
    >美团2019秋面经</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/blog/%E7%BE%8E%E5%9B%A2/" class="article-date">
  <time datetime="2020-05-26T05:26:02.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>1、RESTful调用和 RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service Mesh，如果了解Service Mesh是用来解决什么问题的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、RESTful是一种软件架构风格，用于约束客户端和服务器交互，满足这些约束条件和原则的应用程序或设计就是 RESTful。比如HTTP协议使用同一个URL地址，通过GET，POST，PUT，DELETE等方式实现查询、提交、删除数据。RPC是远程过程调用，是用于解决分布式系统服务间调用的一种方式。RPC采用客户端与服务端模式，双方通过约定的接口（常见为通过IDL定义或者是代码定义）以类似本地方法调用的方式来进行交互，客户端根据约定传输调用函数+参数给服务端（一般是网络传输TCP&#x2F;UDP），服务端处理完按照约定将返回值返回给客户端。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重点为RESTful HTTP的约束风格，RPC调用模型。</span><br><span class="line">1、可分为两大部分RPC +服务治理</span><br><span class="line">RPC部分 &#x3D; IDL  +客户端&#x2F;服务端实现层  +协议层 +数据传输层</span><br><span class="line">服务治理 &#x3D;服务管理（注册中心） +服务监控 +服务容灾 +服务鉴权</span><br><span class="line"></span><br><span class="line">2、 Service Mesh为了解决传统微服务框架&quot;胖客户端&quot;方式，引入的如下问题：</span><br><span class="line">与业务无关的服务治理逻辑与业务代码强耦合，框架、SDK的升级与业务代码强绑定，多语言的胖客户端支持起来性价比极低。</span><br></pre></td></tr></table></figure>

<p>2、请描述避免多线程竞争时有哪些手段？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) 不可变对象；</span><br><span class="line"></span><br><span class="line">2) 互斥锁；</span><br><span class="line"></span><br><span class="line">3)  ThreadLocal 对象；</span><br><span class="line"></span><br><span class="line">4) CAS；</span><br></pre></td></tr></table></figure>

<p>3、1929年，匈牙利作家Frigyes Karinthy在短篇故事‘Chains’中首次提出的“六度人脉理论”，是指地球上所有的人都可以通过六层以内的熟人链和任何其他人联系起来。我们定义A的‘一度好友’为A直接相识的好友，A的‘二度好友’为A一度好友的好友且与A不是一度好友，A的‘三度好友’为A二度好友的好友且与A不是一度好友、二度好友，以此类推。</p>
<p>在美团点评，小美、小团、小卓、小越、小诚、小信的好友关系见下图。</p>
<p><img src="/home/yz/codespace/blog/blog/img/meituan-1.png" alt=""></p>
<p>小团、小卓、小诚是小美的一度好友。小越、小信是小美的二度好友。小诚、小越是小信的一度好友，小美、小卓是小信的二度好友，小团是小信的三度好友。</p>
<p>现在已知每个人的所有一度好友，需要为‘小点’推荐10个六度好友，请使用伪代码写出计算方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node[] friends;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Node)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Node node = (Node) o;</span><br><span class="line">            <span class="keyword">return</span> Arrays.equals(getFriends(), node.getFriends()) &amp;&amp;</span><br><span class="line">                    getName().equals(node.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = Objects.hash(getName());</span><br><span class="line">            result = <span class="number">31</span> * result + Arrays.hashCode(getFriends());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Node[] getFriends() &#123;</span><br><span class="line">            <span class="keyword">return</span> friends;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFriends</span><span class="params">(Node[] friends)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.friends = friends;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Node[] sixDegreeFriend(Node node) &#123;</span><br><span class="line">        Queue&lt;Node&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;Node&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Node nodeFlag = <span class="keyword">new</span> Node();</span><br><span class="line">        nodeQueue.add(node);</span><br><span class="line">        nodeQueue.add(nodeFlag);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nodeQueue.isEmpty())&#123;</span><br><span class="line">            Node node1 = nodeQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node1==nodeFlag)&#123;</span><br><span class="line">                level++;</span><br><span class="line">                <span class="keyword">if</span> (level==<span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nodeQueue.add(nodeFlag);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(node1);</span><br><span class="line">            <span class="keyword">for</span> (Node node2:node1.friends)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!nodeSet.contains(node2)) &#123;</span><br><span class="line">                    nodeQueue.add(node2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Node [] result=nodeQueue.toArray(<span class="keyword">new</span> Node[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (result.length&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            result = Arrays.copyOf(result, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>4、请简述HTTP的5个常用Method及其含义，以及5个常用Status Code及其含义？HTTP与HTTPS的区别是什么，简述一下HTTPS的实现原理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Method：</span><br><span class="line">POST</span><br><span class="line">DELETE</span><br><span class="line">PUT</span><br><span class="line">GET</span><br><span class="line">HEAD</span><br><span class="line">Status Code :</span><br><span class="line">200 请求成功</span><br><span class="line">404 Not Found</span><br><span class="line">403 Forbidden 禁止访问</span><br><span class="line">400 请求的语法错误</span><br><span class="line">500 服务器内部错误</span><br><span class="line">HTTPS 原理</span><br><span class="line">1、浏览器发起往服务器的443端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。</span><br><span class="line"></span><br><span class="line">2、服务器收到请求，选择浏览器支持的加密算法和哈希算法。</span><br><span class="line"></span><br><span class="line">3、服务器下将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。</span><br><span class="line"></span><br><span class="line">4、浏览器进入数字证书认证环节，这一部分是浏览器内置的TLS完成的：</span><br><span class="line"></span><br><span class="line">4.1 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。</span><br><span class="line"></span><br><span class="line">4.2 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性（验证过程类似上面Bob和Susan的通信）。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。</span><br><span class="line"></span><br><span class="line">4.3 浏览器生成一个随机数R，并使用网站公钥对R进行加密。</span><br><span class="line"></span><br><span class="line">5、浏览器将加密的R传送给服务器。</span><br><span class="line"></span><br><span class="line">6、服务器用自己的私钥解密得到R。</span><br><span class="line"></span><br><span class="line">7、服务器以R为密钥使用了对称加密算法加密网页内容并传输给浏览器。</span><br><span class="line"></span><br><span class="line">8、浏览器以R为密钥使用之前约定好的解密算法获取网页内容。</span><br></pre></td></tr></table></figure>

<p>5、给出一个布尔表达式的字符串，比如：true or false and false，表达式只包含true，false，and和or，现在要对这个表达式进行布尔求值，计算结果为真时输出true、为假时输出false，不合法的表达时输出error（比如：true true）。表达式求值是注意and 的优先级比 or 要高，比如：true or false and false，等价于 true or (false and false)，计算结果是 true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br></pre></td></tr></table></figure>

<p>6、给出两个字符串，分别是模式串P和目标串T，判断模式串和目标串是否匹配，匹配输出 1，不匹配输出 0。模式串中‘？’可以匹配目标串中的任何字符，模式串中的 ’*’可以匹配目标串中的任何长度的串，模式串的其它字符必须和目标串的字符匹配。例如P=a?b，T=acb，则P 和 T 匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br></pre></td></tr></table></figure>

<p>7、打车派单场景, 假定有N个订单， 待分配给N个司机。每个订单在匹配司机前，会对候选司机进行打分，打分的结果保存在N*N的矩阵A， 其中Aij 代表订单i司机j匹配的分值。</p>
<p>假定每个订单只能派给一位司机，司机只能分配到一个订单。求最终的派单结果，使得匹配的订单和司机的分值累加起来最大，并且所有订单得到分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>8、2110年美团外卖火星第3000号配送站点有26名骑手，分别以大写字母A-Z命名，因此可以称呼这些骑手为黄家骑士特工A，黄家骑士特工B…黄家骑士特工Z，某美团黑珍珠餐厅的外卖流水线上会顺序产出一组包裹，美团配送调度引擎已经将包裹分配到骑手，并在包裹上粘贴好骑手名称，如RETTEBTAE代表一组流水线包裹共9个，同时分配给了名字为A B E R T的5名骑手。请在不打乱流水线产出顺序的情况下，把这组包裹划分为尽可能多的片段，同一个骑手只会出现在其中的一个片段，返回一个表示每个包裹片段的长度的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>9、已知一种新的火星文的单词由英文字母（仅小写字母）组成，但是此火星文中的字母先后顺序未知。给出一组非空的火星文单词，且此组单词已经按火星文字典序进行好了排序（从小到大），请推断出此火星文中的字母先后顺序。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-interview/做题感想" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/26/interview/%E5%81%9A%E9%A2%98%E6%84%9F%E6%83%B3/"
    >刷题</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/interview/%E5%81%9A%E9%A2%98%E6%84%9F%E6%83%B3/" class="article-date">
  <time datetime="2020-05-26T05:26:02.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="跳跃游戏2"><a href="#跳跃游戏2" class="headerlink" title="跳跃游戏2"></a>跳跃游戏2</h1><p>  /**<br>     * 给定一个非负整数数组，你最初位于数组的第一个位置。<br>     * <p><br>     * 数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>     * <p><br>     * 你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br>     * <p><br>     * 来源：力扣（LeetCode）<br>     * 链接：<a href="https://leetcode-cn.com/problems/jump-game-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game-ii</a><br>     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>     * 输入: [2,3,1,1,4]<br>     * 输出: 2<br>     * 解释: 跳到最后一个位置的最小跳跃数是 2。<br>     *      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>     * <p><br>     * 来源：力扣（LeetCode）<br>     * 链接：<a href="https://leetcode-cn.com/problems/jump-game-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game-ii</a><br>     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>     *<br>     * @param nums<br>     * @return<br>     */</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 给定一个非负整数数组，你最初位于数组的第一个位置。</span></span><br><span class="line"><span class="comment">          * &lt;p&gt;</span></span><br><span class="line"><span class="comment">          * 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span></span><br><span class="line"><span class="comment">          * &lt;p&gt;</span></span><br><span class="line"><span class="comment">          * 你的目标是使用最少的跳跃次数到达数组的最后一个位置。</span></span><br><span class="line"><span class="comment">          * &lt;p&gt;</span></span><br><span class="line"><span class="comment">          * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">          * 链接：https://leetcode-cn.com/problems/jump-game-ii</span></span><br><span class="line"><span class="comment">          * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">          * 输入: [2,3,1,1,4]</span></span><br><span class="line"><span class="comment">          * 输出: 2</span></span><br><span class="line"><span class="comment">          * 解释: 跳到最后一个位置的最小跳跃数是 2。</span></span><br><span class="line"><span class="comment">          *      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span></span><br><span class="line"><span class="comment">          * &lt;p&gt;</span></span><br><span class="line"><span class="comment">          * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">          * 链接：https://leetcode-cn.com/problems/jump-game-ii</span></span><br><span class="line"><span class="comment">          * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">          * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">       <span class="function">xzsfhfeefdfwwpublic <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">/</span><br><span class="line">                <span class="keyword">int</span>[] steps = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">                Arrays.fill(steps, Integer.MAX_VALUE);</span><br><span class="line">                steps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; ((j + i) &lt; nums.length); j++) &#123;</span><br><span class="line">                        steps[i + j] = Math.min(steps[i] + <span class="number">1</span>, steps[i + j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> steps[steps.length - <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>上述思路显而易见，就是暴力法，下面解法很巧妙</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> reach = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> nextreach = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">      nextreach = Math.max(i+nums[i],nextreach);</span><br><span class="line">      <span class="keyword">if</span>(nextreach &gt;= nums.length-<span class="number">1</span>) <span class="keyword">return</span> (step+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(i == reach)&#123;</span><br><span class="line">          step++;</span><br><span class="line">          reach = nextreach;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-interview/快手一面" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/26/interview/%E5%BF%AB%E6%89%8B%E4%B8%80%E9%9D%A2/"
    >快手2019秋一面</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/interview/%E5%BF%AB%E6%89%8B%E4%B8%80%E9%9D%A2/" class="article-date">
  <time datetime="2020-05-26T05:26:02.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <ul>
<li>自我介绍一下</li>
<li>你学过的比较好的课程</li>
<li>java有哪些基础类型</li>
<li>int 和byte的区别</li>
<li>除了基础了类型还有哪些类型</li>
<li>进程和线程的区别</li>
<li>java一个程序可以开几个线程</li>
<li>给定一串连续数字,会缺失一个数字,求找出这个数字,如  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input: &#123;0,1,2,4,5,6&#125;</span><br><span class="line">output &#123;3&#125;</span><br></pre></td></tr></table></figure>
因为做这道题做太久了,后面面试官就没有再问,应该是没有二面了.</li>
</ul>
<p>9.4 227 18.30</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-blog/面试清单" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/26/blog/%E9%9D%A2%E8%AF%95%E6%B8%85%E5%8D%95/"
    >面试清单（抄于知乎）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/blog/%E9%9D%A2%E8%AF%95%E6%B8%85%E5%8D%95/" class="article-date">
  <time datetime="2020-05-26T05:26:02.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><strong>面试清单（Java岗）</strong></p>
<p>Java+JVM+数据库+算法+Spring+中间件+设计模式</p>
<h1 id="01-JAVA基础"><a href="#01-JAVA基础" class="headerlink" title="01 JAVA基础"></a>01 JAVA基础</h1><h2 id="1-1-java知识点"><a href="#1-1-java知识点" class="headerlink" title="1.1 java知识点"></a>1.1 java知识点</h2><p>Hashmap 源码级掌握，扩容，红黑树，最小树化容量，hash冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么8的时候树化，4不可以吗，等等<br>concureentHashMap，段锁，如何分段，和hashmap在hash上的区别，性能，等等<br>HashTable ，同步锁，这块可能会问你synchronized关键字 1.6之后提升了什么，怎么提升的这些<br>ArrayList 优势，扩容，什么时候用<br>LinkedList 优势，什么时候用，和arraylist的区别 等等<br>基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理<br>String ，StringBuffer，StringBuilder哪个是安全的<br>字符串编码的区别，被问到过，我觉得比较容易被忽视的一个点<br>什么是泛型，怎么用泛型<br>static能不能修饰threadLocal，为什么，这道题我当时一听到其实挺懵逼的<br>Comparable和Comparator接口是干什么的，其区别<br>多态的原理是什么，感觉这个很容易被问到<br>接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板~ 然后又交流了一下各自的想法<br>如何通过反射和设置对象私有字段的值<br>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么<br>synchronized 的实现原理以及锁优化？<br>volatile 的实现原理？<br>Java 的信号灯？<br>synchronized 在静态方法和普通方法的区别？<br>怎么实现所有线程在等待某个事件的发生才会去执行？<br>CAS？CAS 有什么缺陷，如何解决？<br>synchronized 和 lock 有什么区别？<br>Hashtable 是怎么加锁的 ？<br>List，Map，Set接口在取元素师，各有什么特点<br>如何线程安全的实现一个计数器<br>生产者消费者模式，要求手写过代码，还是要知道的<br>单例模式，饿汉式，懒汉式，线程安全的做法，两次判断instance是否为空，每次判断的作用是什么。<br>线程池，这个还是很重要的，在生产中用的挺多，四个线程池类型，其参数，参数的理解很重要，corepoolSize怎么设置，maxpoolsize怎么设置，keep-alive各种的，和美团面试官探讨过阻塞队列在生产中的设置，他说他一般设置为0，防止用户阻塞<br>cyclicbarrier 和countdownlatch的区别，个人理解 赛马和点火箭<br>线程回调，这块 被问过让我设计一个RPC，怎么实现，其实用到了回调这块的东西<br>sleep 和yeild方法有什么区别<br>volatile关键字，可见性。<br>乐观锁和悲观锁的使用场景<br>悲观锁的常见实现方式：lock synchronized retreentlock<br>乐观锁：CAS MVCC<br>读写锁的实现方式，16位int的前八位和后八位分别作为读锁和写锁的标志位<br>死锁的条件，怎么解除死锁，怎么观测死锁。<br>希望大家能够好好看一下反射的原理，怎么确定类，怎么调方法<br>RPC框架，同步异步，响应时间，这些都被问到过，还让设计过<br>同步，异步，阻塞，非阻塞 在深信服的面试中遇到过，最好再找一些应用场景加以理解<br>1.2 JVM</p>
<p>内存模型以及分区，需要详细到每个区放什么。<br>堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。<br>对象创建方法，对象的内存分配，对象的访问定位。<br>GC 的两种判定方法<br>GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？<br>GC 收集器有哪些？CMS 收集器与 G1 收集器的特点<br>Minor GC 与 Full GC 分别在什么时候发生？<br>JVM 内存分哪几个区，每个区的作用是什么?<br>如和判断一个对象是否存活?(或者 GC 对象的判定方法)<br>java 中垃圾收集的方法有哪些?<br>类加载器双亲委派模型机制？<br>java 内存模型，java 类加载过程?<br>什么是类加载器，类加载器有哪些?<br>简述 java 内存分配与回收策率以及 Minor GC 和Major GC<br>02 数据库<br>2.1 MySQL</p>
<p>事务四大特性（ACID）原子性、一致性、隔离性、持久性？<br>事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？<br>MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？<br>MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？<br>查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序<br>索引为什么要用B+树，B+树和B-树的区别是什么<br>mysql的默认事务级别，一共有哪些事务级别<br>mysql的一些语句，这些肯定需要掌握的<br>mysql锁，行锁，表锁 ，什么时候发生锁，怎么锁，原理<br>数据库优化，最左原则啊，水平分表，垂直分表<br>什么是临时表，临时表什么时候删除?<br>MySQL B+Tree索引和Hash索引的区别？<br>sql查询语句确定创建哪种类型的索引？如何优化查询？<br>聚集索引和非聚集索引区别？<br>有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？<br>非关系型数据库和关系型数据库区别，优势比较？<br>数据库三范式，根据某个场景设计数据表？<br>数据库的读写分离、主从复制，主从复制分析的 7 个问题？<br>使用explain优化sql和索引？<br>MySQL慢查询怎么解决？<br>什么是 内连接、外连接、交叉连接、笛卡尔积等？<br>mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？<br>varchar和char的使用场景？<br>mysql 高并发环境解决方案？<br>数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？<br>03 Spring相关<br>spring的两大特性- ioc aop，实现原理<br>如果存在A依赖B，B依赖A，那么是怎么加到IOC中去的<br>beanFactory的理解，怎么加载bean<br>FactoryBean的理解<br>基于注解的形式，是怎么实现的， 你知道其原理吗，说一下<br>依赖冲突，有碰到过吗，你是怎么解决的~<br>bean的生命周期<br>spring中的自动装配方式<br>BeanFactory 和 FactoryBean<br>Spring IOC 的理解，其初始化过程？<br>BeanFactory 和 ApplicationContext？<br>Spring Bean 的生命周期，如何被管理的？Spring Bean 的加载过程是怎样的？<br>如果要你实现Spring AOP，请问怎么实现？<br>如果要你实现Spring IOC，你会注意哪些问题？<br>Spring 是如何管理事务的，事务管理机制？<br>Spring 的不同事务传播行为有哪些，干什么用的？<br>Spring 中用到了那些设计模式？<br>Spring MVC 的工作原理？<br>Spring 循环注入的原理？<br>Spring 如何保证 Controller 并发的安全？<br>你一般是怎么对mvc项目进行分层的<br>dispatch-servlet的工作原理<br>为什么有了springmvc还要在项目中使用spring？<br>springmvc的运行机制，dispatch -》 hanldermapping-—》handler -》handlerAdapter-》执行handler-》modelandview -》 返回mv -》 视图解析器-》返回view -》 渲染响应<br>怎么防止依赖注入<br>怎么让mapper 和xml对应<br>如何自动包装对象<br>和spring相比，做了什么改变<br>starter你知道哪些<br>如何部署springmvc项目 以及如何部署springboot项目<br>springboot的插件，你使用过哪些<br>04 中间件<br>4.1 redis<br>Redis用过哪些数据数据，以及Redis底层怎么实现<br>Redis缓存穿透，缓存雪崩<br>如何使用Redis来实现分布式锁<br>Redis的并发竞争问题如何解决<br>Redis持久化的几种方式，优缺点是什么，怎么实现的<br>Redis的缓存失效策略<br>Redis集群，高可用，原理<br>Redis缓存分片，Redis的数据淘汰策略<br>为什么选择redis，有什么好处，基于内存，抗压<br>redis集群怎么进行数据分配，hash槽<br>redis的主从复制是怎么实现的<br>redis的数据结构 最常问 hash是什么， sorted set怎么实现的<br>因为项目的原因，问我redis是怎么保证高可用的，主从和集群怎么加在一起<br>redis 和memcache的区别<br>redis 分布式锁的实现原理 setNX 啥的<br>redis模拟session，除了redis你还考虑过别的吗<br>redis的缓存击穿，怎么处理这个问题<br>redis是基于内存的，那么它有持久化吗，aof rdb<br>aof和rdb的优缺点，你在项目中使用的哪一个<br>4.2 MQ<br>为什么选择rabbitMQ， 社区活跃，高并发<br>别的MQ也要了解，比如RocketMQ(阿里的，java开发，再次开发，并发高，分布式，出错少)<br>ActiveMQ， kafka<br>topic 和 block<br>MQ的作用，同步转异步，消除峰值<br>如何保证数据一致性，即原子性，ack<br>消息队列在项目中的应用<br>4.3 nginx<br>怎么配置负载均衡<br>怎么限流<br>怎么使用nginx缓存<br>为什么使用nginx，有别的替代品吗<br>请解释 x Nginx 如何处理 P HTTP 请求<br>在 x Nginx 中，如何使用未定义的服务器名称来阻止处理请求? ?<br>使用“ 反向代理服务器 ” 的优点是什么?<br>x Nginx 服务器上的 r Master 和 和 r Worker 进程分别是什么?<br>nginx的压力测试，你测试过吗，能抗住多少压力<br>你如何通过不同于 0 80 的端口开启 Nginx?<br>是否有可能将 x Nginx 的错误替换为 2 502 错误、 503<br>s stub_status 和 和 r sub_filter 指令的作用是什么? ?<br>4.5 dubbo<br>原理，怎么用<br>和erueka有什么区别<br>为什么要用dubbo，不用行不行？<br>跨域请求的一些知识点<br>Dubbo 支持哪些协议，每种协议的应用场景，优缺点？<br>Dubbo 超时时间怎样设置？<br>Dubbo 集群的负载均衡有哪些策略<br>Dubbo 的主要应用场景？<br>Dubbo 服务注册与发现的流程？<br>Dubbo 中 中 zookeeper 做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？<br>dubbo 服务负载均衡策略？<br>05 其他插件<br>5.1 shiro<br>怎么做权限控制<br>为什么使用shiro，你直接使用aop不也是一样的吗，shiro还有标签<del>各种扯<br>shiro的两个最重要的函数<br>认证和授权是怎么做的<br>5.2 docker<br>和vmware的区别<br>你一般是怎么部署的 IDEA，直接把项目部署到docker并打包到云服务器<br>docker的好处，小，快<br>06 Linux<br>常见的命令<br>sed 和 awk 感觉linux必考。。<br>linux的使用场景，你什么时候会用linux – 》 布置服务器<br>怎么查看进程和杀死进程<br>打印一个文件夹中的所有文件<br>float在计算机中是怎么存储的，当时被问到的时候，我也在问自己，怎么存的</del> 佛了<br>线程和进程的区别<br>线程的通信方式，进程的通信方式<br>系统线程的数量上限是多少<br>页式存储的概念<br>内存碎片，你有了解过吗，有想过解决方案吗~<br>07 算法<br>7.1 排序算法<br>八大排序算法真的是面试宠儿<br>最常考 快速排序 和归并排序<br>哪些排序算法是稳定的 哪些是不稳定的<br>堆排 也应该掌握<br>7.2 树<br>根据遍历结果恢复树，递归<br>二叉搜索树第k大<br>树的和为k的路径<br>层次遍历<br>根据层次遍历和后序遍历恢复树<br>镜像树<br>树的深度<br>是不是平衡二叉树<br>7.3 链表<br>反转链表<br>链表环的入口<br>交叉链表的交点<br>复杂链表的复制<br>二叉搜索树变成双向链表<br>7.4 回溯算法<br>走迷宫<br>游戏通关<br>7.5 递推算法<br>走台阶<br>断钢筋<br>7.6 背包问题<br>装最多的东西<br>7.7 贪心算法<br>覆盖问题<br>时间问题<br>08 设计模式<br>面试中设计模式其实也是挺重要的</p>
<p>Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式<br>在 Java 中，什么叫观察者设计模式（observer design pattern）<br>使用工厂模式最主要的好处是什么？在哪里使用<br>举一个用 Java 实现的装饰模式(decorator design pattern) ？它是作用于对象层次还是类层次？<br>在 Java 中，什么时候用重载，什么时候用重写？<br>举例说明什么情况下会更倾向于使用抽象类而不是接口<br>观察者模式<br>适配模式<br>工厂模式<br>…</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8A%9D%E5%A3%AB/" rel="tag">芝士</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-interview/拼多多一面" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/26/interview/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E4%B8%80%E9%9D%A2/"
    >拼多多2019秋一面</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/interview/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E4%B8%80%E9%9D%A2/" class="article-date">
  <time datetime="2020-05-26T05:26:02.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>自我介绍</li>
<li>熟悉的语言是什么<ul>
<li>java</li>
</ul>
</li>
<li>用过那些java的容器类<ul>
<li>HashMap、HashSet、ArrayList、LinkList</li>
</ul>
</li>
<li>HashTable与CurrentHashMap的区别<ul>
<li>HashTable key和value 不能为空值，CurrentHashMap可以</li>
<li>CurrentHashMap的加锁的粒度更小，所以性能要高一点</li>
</ul>
</li>
<li>为什么CurrentHashMap性能要高一点<ul>
<li>加锁的粒度更小，加在目标桶上，同时其它对其他桶的操作与读取</li>
<li>java8以后CurrentHashMap从Synchronized改使用CAS实现，即乐观锁，提高了性能</li>
</ul>
</li>
<li>HashMap查询效率特别低的话，总是发生碰撞有什么办法优化<ul>
<li>扩容</li>
</ul>
</li>
<li>不能扩容呢，一个链表特别长<ul>
<li>把链表转化成查找树，可以实现O(log n)的复杂度</li>
</ul>
</li>
<li>你知道哪些查找树呢，这里用什么好    <ul>
<li>（突然蒙了），就一般的查找树就好</li>
</ul>
</li>
<li>一般得得得查找树的最坏的复杂度是多少呢<ul>
<li>O(n)，如果树一边倒的话，相当一个链表</li>
</ul>
</li>
<li>红黑树有了解过吗，这里用红黑树行不行<ul>
<li>可以，但是我实现不出来，仅限了解</li>
</ul>
</li>
<li>为什么可以呢<ul>
<li>因为红黑树维护这一个性质，根节点到叶节点的路径上有相同的黑色节点，这样保证了平衡性</li>
</ul>
</li>
<li>你知道哪些垃圾回收器<ul>
<li>（蒙～）</li>
</ul>
</li>
<li>哪些回收算法<ul>
<li>新生代和老年代有不同的算法，新生是标记需要回收的，然后直接回收，老年把需要回收的对象移动到一端，然后清除</li>
</ul>
</li>
<li>怎么判断新生代老年代<ul>
<li>一般先放在新生代，若干次新生代回收后还没有被回收的话转移到老年代，也有例外，比如大对象可能直接放入到老年代</li>
</ul>
</li>
<li>怎么判断对象需要回收、从哪开始找  <ul>
<li>没有引用时，从根节点开始</li>
</ul>
</li>
<li>哪些可以当成根节点<ul>
<li>忘了</li>
</ul>
</li>
<li>java类加载的过程<ul>
<li>不太了解，好像是什么双亲加载模型什么的，就是要加载这个对象前先从父亲代加载，依次递归下去</li>
</ul>
</li>
<li>计算机中段和页知道吗<ul>
<li>不了解</li>
</ul>
</li>
<li>mysql中有哪些引擎<ul>
<li>MyIsam Innodb ，My不支持事务安全，使用文件保存，方便转移，粒度表级，更适合查询，适合小型项目，Innodb支持事务安全、粒度行级、写效率高，适合复杂的项目</li>
</ul>
</li>
<li>Innodb 使用什么索引<ul>
<li>懵，好像是B+树  </li>
</ul>
</li>
<li>为什么使用B+树，B+树有什么特点<ul>
<li>这里答乱七八糟、略</li>
</ul>
</li>
<li>B+树为什么把所有放在叶节点<ul>
<li>维护树的平衡性，降低树的高度</li>
</ul>
</li>
<li>有用过哪些Nosql，各自有什么特点</li>
<li>问了一个项目</li>
<li>通过短信给用户发送一个长链接，但短信长度有限，可能链接放不下你怎么解决<ul>
<li>使用t.cn类似的短链接</li>
</ul>
</li>
<li>你实现这个t.cn的功能<ul>
<li>可以后台生成一个Host+编号的短连接，然后重定向到对应的长链接，编号的方式可以采用时间戳</li>
</ul>
</li>
<li>要求生成链接是杂乱的，不要暴露编号<ul>
<li>比如只使用小写字母和大写字母，就可以得到一个52进制的表示方法，如a表示1，z表示26，az表示53+26=79</li>
</ul>
</li>
<li>你有什么问题问我吗<ul>
<li>你们后端开发一般用什么<ul>
<li>java的多一点，也有c++等其他语言</li>
</ul>
</li>
<li>今晚表现的最差的一点是哪里<ul>
<li>作为应届生，虽然课程没教，但基础的还是应该学好一点（这里应该指段和页那题，我说的是没上过计算级系统这门课，可能和其他基础没打出来也有关系，这言外之意就是“你基础不太行”，所以理论上应该没有二面了）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>果然又败在了基础部分。这次面试心态还可以，这么多没答出来，依然面不改色，这是进步点，当然也有面试官氛围维持好的原因。</p>
<h1 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h1><h2 id="计算机中的段和页"><a href="#计算机中的段和页" class="headerlink" title="计算机中的段和页"></a>计算机中的段和页</h2><p>一个段中包含若干页，在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。<br>在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）<br>两者结合——段页式存储管理：内存分为几个段，每个段分为大小相同的页，主存分配以页为单位。地址结构：段号、页号、页内偏移量。每个进程一个段表，每个段一个页表。<br>2．地址变换的过程：<br>（1）程序执行时，从PCB中取出段表始址和段表长度，装入段表寄存器。<br>（2）由地址变换机构将逻辑地址自动分成段号、页号和页内地址。<br>（3）将段号与段表长度进行比较，若段号大于或等于段表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。<br>（4）将段表始址与段号和段表项长度的乘积相加，便得到该段表项在段表中的位置。<br>（5）取出段描述子得到该段的页表始址和页表长度。<br>（6）将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。<br>（7）将页表始址与页号和页表项长度的乘积相加，便得到该页表项在页表中的位置。<br>（8）取出页描述子得到该页的物理块号。<br>（9）对该页的存取控制进行检查。<br>（10）将物理块号送入物理地址寄存器中，再将有效地址寄存器中的页内地址直接送入物理地址寄存器的块内地址字段中，拼接得到实际的物理地址。</p>
<hr>
<h2 id="操作系统相关知识"><a href="#操作系统相关知识" class="headerlink" title="操作系统相关知识"></a>操作系统相关知识</h2><ol>
<li><p>进程间的通信的几种方式  </p>
<ul>
<li><p>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p>
</li>
<li><p>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p>
</li>
<li><p>消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>
</li>
<li><p>共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</p>
</li>
<li><p>信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</p>
</li>
<li><p>套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。  </p>
</li>
</ul>
</li>
<li><p>进程状态</p>
<ul>
<li>就绪状态，已获得除cpu的所需资源</li>
<li>运行状态，处于此状态的进程数不大于cpu数</li>
<li>阻塞状态</li>
</ul>
</li>
<li><p>进程调度策略</p>
<ul>
<li>FCFS：先来的先得</li>
<li>SJF ：最短作业优先调度算法，使平均等待时间最短</li>
<li>优先级调度算法，优先级越高越先分配，相同优先级先到先得，问题是低优先级线程可能会饿死，即无限等待</li>
<li>时间片轮转调度算法： 每个轮流使用一个时间片后，放回就绪队列</li>
<li>多级队列调度算发：将就绪对列分成多个独立的队列，队列间按优先级抢占调度</li>
<li>多级反馈队列调度算法</li>
</ul>
</li>
<li><p>进程同步机制<br>原子操作<br>信号量操作<br>自旋锁管程<br>回合<br>分布式系统</p>
</li>
</ol>
<hr>
<p>线程同步方式  </p>
<ul>
<li>互斥量：只有拥有互斥对象的线程才有访问公共资源的权限。</li>
<li>信号量：允许多个线程同一时刻访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
</ul>
<ul>
<li>事件（信号）：通知操作保持多线程同步</li>
</ul>
<p>线程状态：<br>创建<br>就绪<br>运行<br>阻塞<br>等待<br>时间等待<br>终止<br><img src="./image/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.jpg" alt="线程状态"></p>
<hr>
<p>死锁</p>
<ol>
<li>概念<br>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。  </li>
<li>产生死锁的4个必要条件<ul>
<li>互斥：至少有一个资源一次只能被一个进程占有</li>
<li>占有等待：一个进程占有至少一个资源，并等待另一个被其他进程占有的资源</li>
<li>非抢占：资源只能在进程完成后资源释放</li>
<li>循环等待：若干进程形成环形等待关系</li>
</ul>
</li>
<li>死锁处理<ul>
<li>预防</li>
<li>避免，动态检测资源状态</li>
<li>解除，进程终止，资源抢占  </li>
</ul>
</li>
</ol>
<hr>
<p>虚拟内存</p>
<ol>
<li>页面置换算法<ul>
<li>FIFO先进先出算法</li>
<li>LRU 最少使用算法：根据使用时间</li>
<li>LFU 最少使用次数算法</li>
<li>OPT 最有置换算法 理论最优，保证置换出去的的页是不再使用的页<h2 id="java类的加载过程"><a href="#java类的加载过程" class="headerlink" title="java类的加载过程"></a>java类的加载过程</h2></li>
</ul>
</li>
<li>加载  </li>
<li>验证<br>文件格式验证：验证字节流是否符合Class文件规范<br>元数据验证：对字节流进行语义分析，是否符合java语言语法的规范<br>字节码验证：分析数据流和控制，保证该类不会危害虚拟机<br>符号引用验证：对常量池中中各种符号引用进行匹配性校验</li>
<li>准备<br>为类变量进行内存分配设置初始值为0（0，null，false等），这些内存在方法区分配<br>但是如果变量被static final ,则在准备阶段就被初始化。  <strong>可以理解为放入调动它的类的常量池中</strong> </li>
<li>解析<br>讲常量池中的符号引用转化为直接引用。可能在之前也可能在之后开始。  <ul>
<li>类或接口</li>
<li>字段解析</li>
<li>类方法解析</li>
<li>接口方法解析</li>
</ul>
</li>
<li>初始化<br>虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：<ul>
<li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。</li>
<li>使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="jvm垃圾回收"><a href="#jvm垃圾回收" class="headerlink" title="jvm垃圾回收"></a>jvm垃圾回收</h2><hr>
<p>##参考</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-interview/网易有道一面" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/26/interview/%E7%BD%91%E6%98%93%E6%9C%89%E9%81%93%E4%B8%80%E9%9D%A2/"
    >网易有道2019秋一面</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/interview/%E7%BD%91%E6%98%93%E6%9C%89%E9%81%93%E4%B8%80%E9%9D%A2/" class="article-date">
  <time datetime="2020-05-26T05:26:02.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="一-面试问题"><a href="#一-面试问题" class="headerlink" title="一. 面试问题"></a>一. 面试问题</h1><p>此次面试主要是围着我自我介绍时说的一些自己做的项目提的问题, 比如</p>
<h2 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h2><h2 id="2-java-类的加载过程"><a href="#2-java-类的加载过程" class="headerlink" title="2. java 类的加载过程"></a>2. java 类的加载过程</h2><h2 id="３-java-类的查找过程"><a href="#３-java-类的查找过程" class="headerlink" title="３. java 类的查找过程"></a><strong>３. java 类的查找过程</strong></h2><h2 id="springMVC的配置过程"><a href="#springMVC的配置过程" class="headerlink" title="springMVC的配置过程"></a>springMVC的配置过程</h2><h2 id="jvm虚拟机怎么指定老年代新生代的大小"><a href="#jvm虚拟机怎么指定老年代新生代的大小" class="headerlink" title="jvm虚拟机怎么指定老年代新生代的大小?"></a>jvm虚拟机怎么指定老年代新生代的大小?</h2><h2 id="jvm什么时候要调整新生代老年代大小"><a href="#jvm什么时候要调整新生代老年代大小" class="headerlink" title="jvm什么时候要调整新生代老年代大小"></a>jvm什么时候要调整新生代老年代大小</h2><h2 id="springcloud有用过"><a href="#springcloud有用过" class="headerlink" title="springcloud有用过?"></a>springcloud有用过?</h2><h2 id="搭私服maven-的seting-poml文件有哪些特殊设置"><a href="#搭私服maven-的seting-poml文件有哪些特殊设置" class="headerlink" title="搭私服maven 的seting,poml文件有哪些特殊设置"></a>搭私服maven 的seting,poml文件有哪些特殊设置</h2><h2 id="poi的相关使用"><a href="#poi的相关使用" class="headerlink" title="poi的相关使用"></a>poi的相关使用</h2><h2 id="java-线程池相关知识"><a href="#java-线程池相关知识" class="headerlink" title="java 线程池相关知识"></a>java 线程池相关知识</h2><p>一面挂掉</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-interview/笔记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/26/interview/%E7%AC%94%E8%AE%B0/"
    >java笔记</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/interview/%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-05-26T05:26:02.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <ul>
<li><a href="#%e4%b8%80-java%e7%9f%a5%e8%af%86%e6%80%bb%e7%bb%93">一. Java知识总结</a><ul>
<li><a href="#1-java-4-%e7%89%b9%e5%be%81%e6%8a%bd%e8%b1%a1%e5%b0%81%e8%a3%85%e7%bb%a7%e6%89%bf%e5%a4%9a%e6%80%81">1. java 4 特征：抽象、封装、继承、多态;</a></li>
<li><a href="#2-%e5%85%ad%e5%a4%a7%e5%8e%9f%e5%88%99">2. 六大原则：</a><ul>
<li><a href="#%e5%8d%95%e4%b8%80%e8%81%8c%e8%b4%a3">单一职责</a></li>
<li><a href="#%e5%bc%80%e9%97%ad">开闭</a></li>
<li><a href="#%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2">里氏替换</a></li>
<li><a href="#%e4%be%9d%e8%b5%96%e5%80%92%e7%bd%ae">依赖倒置</a></li>
<li><a href="#%e5%90%88%e6%88%90%e8%81%9a%e5%90%88%e5%a4%8d%e7%94%a8">合成聚合复用</a></li>
<li><a href="#%e6%8e%a5%e5%8f%a3%e9%9a%94%e7%a6%bb">接口隔离</a></li>
<li><a href="#%e7%8b%84%e7%b1%b3%e7%89%b9%e6%b3%95%e5%88%99">狄米特法则</a></li>
</ul>
</li>
<li><a href="#3-23%e7%a7%8d%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">3. 23种设计模式</a><ul>
<li><a href="#%e5%88%86%e7%b1%bb">分类</a></li>
<li><a href="#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f">单例模式</a></li>
<li><a href="#%e5%8e%9f%e5%9e%8b%e6%a8%a1%e5%bc%8f">原型模式</a></li>
<li><a href="#%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f">工厂模式</a><ul>
<li><a href="#%e7%ae%80%e5%8d%95%e5%b7%a5%e5%8e%82">简单工厂</a></li>
<li><a href="#%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95">工厂方法</a></li>
<li><a href="#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82">抽象工厂</a></li>
</ul>
</li>
<li><a href="#%e5%bb%ba%e9%80%a0%e8%80%85%e6%a8%a1%e5%bc%8f">建造者模式</a></li>
<li><a href="#%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f">代理模式</a></li>
<li><a href="#%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f">适配器模式</a></li>
<li><a href="#%e6%a1%a5%e6%8e%a5%e6%a8%a1%e5%bc%8f">桥接模式</a></li>
<li><a href="#%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f">观察者模式</a></li>
</ul>
</li>
<li><a href="#4-jvm-%e5%86%85%e5%ae%b9">4. jvm 内容</a><ul>
<li><a href="#%e5%b8%b8%e8%a7%81%e7%9a%84gc%e7%a7%8d%e7%b1%bb">常见的GC种类</a><ul>
<li><a href="#serial%e4%b8%b2%e8%a1%8c">serial(串行)</a></li>
<li><a href="#parnew">parNew</a></li>
<li><a href="#parallel-scavebge">parallel Scavebge</a></li>
<li><a href="#serial-old">serial old</a></li>
<li><a href="#parallel-old">parallel old</a></li>
<li><a href="#cms">CMS</a></li>
</ul>
</li>
<li><a href="#minor-gc-%e5%92%8cfull-gc">Minor GC 和Full GC</a></li>
<li><a href="#%e6%96%b0%e7%94%9f%e4%bb%a3%e8%80%81%e5%b9%b4%e4%bb%a3">新生代老年代</a></li>
<li><a href="#4%e7%a7%8d%e5%8f%af%e4%bd%9c%e4%b8%bagc-root%e7%9a%84%e5%af%b9%e8%b1%a1">4种可作为GC root的对象</a></li>
<li><a href="#%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5%e4%b8%8b%e5%88%a4%e6%96%ad%e9%9c%80%e8%a6%81%e8%b0%83%e6%95%b4%e6%96%b0%e7%94%9f%e5%b8%a6%e7%9a%84%e5%a4%a7%e5%b0%8f">什么情况下判断需要调整新生带的大小</a></li>
<li><a href="#jvm%e7%9a%84%e5%b8%b8%e8%a7%81%e5%8f%82%e6%95%b0">jvm的常见参数</a></li>
</ul>
</li>
<li><a href="#static--final">static &amp; final</a><ul>
<li><a href="#hashtablehashmapcurrenthashmap">hashtable、hashmap、currenthashmap:</a></li>
<li><a href="#%e5%ba%8f%e5%88%97%e5%8c%96">序列化：</a></li>
<li><a href="#%e5%a4%9a%e7%ba%bf%e7%a8%8b">多线程：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%e4%ba%8c-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9f%a5%e8%af%86">二. 数据库知识</a><pre><code>- [ACID](#acid)
- [脏读、不可重复读、幻读](#%e8%84%8f%e8%af%bb%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e5%b9%bb%e8%af%bb)
- [索引](#%e7%b4%a2%e5%bc%95)
- [MyISAM和InnoDB](#myisam%e5%92%8cinnodb)
  - [分页查询](#%e5%88%86%e9%a1%b5%e6%9f%a5%e8%af%a2)</code></pre></li>
<li><a href="#%e4%b8%89-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e7%9f%a5%e8%af%86">三. 计算机网络知识</a><ul>
<li><a href="#%e5%8d%8f%e8%ae%ae%e4%b8%89%e8%a6%81%e7%b4%a0">协议三要素</a></li>
<li><a href="#http%e4%b8%8ehttps%e7%9a%84%e5%8c%ba%e5%88%ab">http与https的区别</a></li>
<li><a href="#tcp%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%9b%9b%e6%ad%a4%e6%8c%a5%e6%89%8b">TCP可靠传输&amp;三次握手&amp;四此挥手</a></li>
<li><a href="#ddos%e6%94%bb%e5%87%bb">DDOS攻击</a></li>
<li><a href="#getpost">GET&amp;POST</a></li>
<li><a href="#osi%e6%a8%a1%e5%9e%8b">OSI模型</a><ul>
<li><a href="#6-%e7%bd%91%e7%bb%9c%e5%b1%82">6. 网络层</a></li>
<li><a href="#7-%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82">7. 数据链路层</a><ul>
<li><a href="#71-%e5%a4%9a%e8%b7%af%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e5%8d%8f%e8%ae%aemac">7.1 多路访问控制协议MAC</a></li>
<li><a href="#72-arp%e5%8d%8f%e8%ae%ae">7.2 ARP协议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tcp%e5%bf%ab%e9%80%9f%e9%87%8d%e4%bc%a0">TCP快速重传</a></li>
<li><a href="#5%e7%b1%bbip%e5%9c%b0%e5%9d%80">5类ip地址</a></li>
<li><a href="#%e5%89%91%e6%8c%87off">剑指off</a><h1 id="一-Java知识总结"><a href="#一-Java知识总结" class="headerlink" title="一. Java知识总结"></a>一. Java知识总结</h1></li>
</ul>
</li>
</ul>
<h2 id="1-java-4-特征：抽象、封装、继承、多态"><a href="#1-java-4-特征：抽象、封装、继承、多态" class="headerlink" title="1. java 4 特征：抽象、封装、继承、多态;"></a>1. java 4 特征：抽象、封装、继承、多态;</h2><p>重载：方法同名，参数不同;参数类型、或个数不同，或顺序不同<br>重写：比父类更好访问，最好不要额外申明异常（里氏替换原则），其他返回类型，参数都要相同;</p>
<h2 id="2-六大原则："><a href="#2-六大原则：" class="headerlink" title="2. 六大原则："></a>2. 六大原则：</h2><h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费</p>
<h3 id="开闭"><a href="#开闭" class="headerlink" title="开闭"></a>开闭</h3><p>对扩展开放,对修改关闭  </p>
<h3 id="里氏替换"><a href="#里氏替换" class="headerlink" title="里氏替换"></a>里氏替换</h3><p>父类所拥有的性质在子类仍然成立,即子类可以扩展父类的功能,但不能改变父类原有的功能. </p>
<h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象  </p>
<h3 id="合成聚合复用"><a href="#合成聚合复用" class="headerlink" title="合成聚合复用"></a>合成聚合复用</h3><p>它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<h3 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h3><p>要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。<br>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：<br>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。<br>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p>
<h3 id="狄米特法则"><a href="#狄米特法则" class="headerlink" title="狄米特法则"></a>狄米特法则</h3><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<h2 id="3-23种设计模式"><a href="#3-23种设计模式" class="headerlink" title="3. 23种设计模式"></a>3. 23种设计模式</h2><hr>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>创建型模式<ul>
<li>单例模式</li>
<li>原型模式</li>
<li>工厂模式</li>
<li>建造者模式</li>
</ul>
</li>
<li>结构型模式<ul>
<li>代理</li>
<li>适配器</li>
<li>桥接</li>
<li>装饰</li>
<li>外观</li>
<li>享元</li>
<li>组合</li>
</ul>
</li>
<li>行为型模式<ul>
<li>模版方法</li>
<li>策略</li>
<li>命令</li>
<li>职责链</li>
<li>观察者</li>
<li>中介者</li>
<li>迭代器</li>
<li>备忘录</li>
<li>解释器</li>
</ul>
</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>只产生一个实例，内部新建一个实例，通过static方法返回这个实例</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>复制实例以创建实例</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>主要角色有:抽象工厂,具体工厂,抽象产品,具体产品<br>每个具体工厂对应着具体产品</p>
<h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>可生产多个等级的产品<br><img src="image/3-1Q11416002NW.gif" alt="">  </p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>将一个复杂的对象分解为多个简单的对象,然后一步一步构建而成. 主要角色有产品, 抽象建造者, 具体建造者, 指挥者<br><img src="image/3-1Q1141H441X4.gif" alt="建造者模式"></p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式的主要角色如下。<br>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。<br>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。<br>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。<br><img src="image/3-1Q115093011523.gif" alt=""></p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>类适配器<br><img src="image/3-1Q1151045351c.gif" alt=""><br>对象适配器<br><img src="image/3-1Q1151046105A.gif" alt=""></p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。<br>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。<br>模式的结构<br>桥接（Bridge）模式包含以下主要角色。<br>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。<br>扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。<br>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。<br>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。<br><img src="image/3-1Q115125253H1.gif" alt=""><br>桥接模式通常适用于以下场景。<br>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。<br>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。<br>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。  </p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察对象接口（+observerList、-add、-remove、-change)<br>观察者接口：（-change）<br>当观察者对象改变时调用change函数，遍历调用observerList的观察者的change函数<br>主要角色有:抽象主题, 具体主题, 抽象观察者, 具体观察者<br><img src="image/3-1Q1161A6221S.gif" alt="观察者模式"><br><br><br>实现代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Subject subject=<span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1=<span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2=<span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers=<span class="keyword">new</span> ArrayList&lt;Observer&gt;();   </span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体目标发生改变..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);       </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Observer)obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者1作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者2作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-jvm-内容"><a href="#4-jvm-内容" class="headerlink" title="4. jvm 内容"></a>4. jvm 内容</h2><h3 id="常见的GC种类"><a href="#常见的GC种类" class="headerlink" title="常见的GC种类"></a>常见的GC种类</h3><p><img src="image/1.jpg" alt="HOTSpot"><br>注意:有连线表示可以搭配使用  </p>
<h4 id="serial-串行"><a href="#serial-串行" class="headerlink" title="serial(串行)"></a>serial(串行)</h4><ul>
<li>针对新生代</li>
<li>复制算法</li>
<li>单线程</li>
<li>必须停止所有工作线程即”Stop the word”</li>
<li>多应用于client模式</li>
</ul>
<h4 id="parNew"><a href="#parNew" class="headerlink" title="parNew"></a>parNew</h4><ul>
<li>serial的多线程版本</li>
<li>除多线程特点外和serial一样</li>
<li>多应用于server模式</li>
</ul>
<h4 id="parallel-Scavebge"><a href="#parallel-Scavebge" class="headerlink" title="parallel Scavebge"></a>parallel Scavebge</h4><ul>
<li>吞吐量收集器</li>
<li>复制算法</li>
<li>多线程</li>
<li>目标是达到可控的吞吐量(吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间))</li>
<li>减少垃圾收集时间,以让用户代码获得更长的运行时间</li>
</ul>
<h4 id="serial-old"><a href="#serial-old" class="headerlink" title="serial old"></a>serial old</h4><ul>
<li>serial的老年代版本</li>
<li>老年代</li>
<li>单线程</li>
<li>标记整理(有压缩)</li>
<li>主要client模式</li>
</ul>
<h4 id="parallel-old"><a href="#parallel-old" class="headerlink" title="parallel old"></a>parallel old</h4><ul>
<li>parallel Scavenge的老年代版本</li>
<li>标记整理</li>
<li>多线程 </li>
</ul>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><ul>
<li><p>并发标记清理 低停顿 低延迟</p>
</li>
<li><p>标记清除算法(不压缩,产生内存碎片)</p>
</li>
<li><p>消耗更多内存</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、初始标记</span><br><span class="line">只是标记一下 GC Roots 能直接关联的对象,速度很快,仍然需要暂停所有的工作线程。</span><br><span class="line">2、并发标记</span><br><span class="line">进行 GC Roots 跟踪的过程,和用户线程一起工作,不需要暂停工作线程。</span><br><span class="line">3、重新标记</span><br><span class="line">为了修正在并发标记期间,因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录,仍然需要暂停所有的工作线程。</span><br><span class="line">4、并发清除</span><br><span class="line">清除 GC Roots 不可达对象,和用户线程一起工作,不需要暂停工作线程。由于耗时最长的并</span><br><span class="line">发标记和并发清除过程中,垃圾收集线程可以和用户现在一起并发工作,所以总体上来看</span><br><span class="line">CMS 收集器的内存回收和用户线程是一起并发地执行。</span><br></pre></td></tr></table></figure>

<h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>  Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果,相比与 CMS 收集器,G1 收<br>  集器两个最突出的改进是:</p>
<ol>
<li>基于标记-整理算法,不产生内存碎片。</li>
<li>可以非常精确控制停顿时间,在不牺牲吞吐量前提下,实现低停顿垃圾回收。<br>G1 收集器避免全区域垃圾收集,它把堆内存划分为大小固定的几个独立区域,并且跟踪这些区域<br>的垃圾收集进度,同时在后台维护一个优先级列表,每次根据所允许的收集时间,优先回收垃圾<br>最多的区域。区域划分和优先级区域回收机制,确保 G1 收集器可以在有限时间获得最高的垃圾收<br>集效率。</li>
</ol>
<h3 id="Minor-GC-和Full-GC"><a href="#Minor-GC-和Full-GC" class="headerlink" title="Minor GC 和Full GC"></a>Minor GC 和Full GC</h3><p>MinorGC 是发生在新生代的GC<br>FullGC也称MajorGC,是发生在老年代的GC</p>
<h3 id="新生代老年代"><a href="#新生代老年代" class="headerlink" title="新生代老年代"></a>新生代老年代</h3><p>一般新生代:老年代=1:2<br>新生代包含,Eden:servivor:servivor=8:1:1, 新生代因为对象”朝生夕死”故采用”复制清除法”,把Eden和一个servivor区域的存活对象复制到另一个servivor区域,两个servivor交替使用,即第一次minorGC时把Eden和servivor1的存活对象复制到servivor2,第二次就把Eden和servivor2的的存活对象复制到servivor1中,依次交替下.<br>老年代,一般使用标记整理法.对象放入老年代的原因可能有</p>
<ul>
<li>minorgc中servivor满了还未放进去的对象</li>
<li>大对象</li>
<li>经过多次minorGC还存活的对象(一般16次)</li>
<li>servivor超过一半对象是某个年龄的对象(minor经历过GC的次数称为年龄),那么大于该年龄的对象会直接进入老年代</li>
</ul>
<h3 id="4种可作为GC-root的对象"><a href="#4种可作为GC-root的对象" class="headerlink" title="4种可作为GC root的对象"></a>4种可作为GC root的对象</h3><p>虚拟机栈中引用的对象<br>方法区静态属性引用的对象<br>方法区常量引用的对象<br>本地方法栈中JNI(即一般说的Native方法)引用的对象</p>
<h3 id="4种引用类型"><a href="#4种引用类型" class="headerlink" title="4种引用类型"></a>4种引用类型</h3><p><strong>强引用</strong></p>
<p>Java中默认声明的就是强引用，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">//只要obj还指向Object对象，Object对象就不会被回收</span></span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">//手动置null</span></span><br></pre></td></tr></table></figure>

<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了</p>
<p><strong>软引用</strong></p>
<p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。<br>在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p>
<p>下面以一个例子来进一步说明强引用和软引用的区别：<br>在运行下面的Java代码之前，需要先配置参数 -Xms2M -Xmx3M，将 JVM 的初始内存设为2M，最大可用内存为 3M。</p>
<p>首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOOM</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         testStrongReference();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStrongReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 new byte为 1M 时，程序运行正常</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果我们将</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>替换为创建一个大小为 2M 的字节数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>则内存不够使用，程序直接报OOM，强引用并不会被回收</p>
<p>接着来看一下软引用会有什么不一样，在下面的示例中连续创建了 10 个大小为 1M 的字节数组，并赋值给了软引用，然后循环遍历将这些对象打印出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         testSoftReference();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSoftReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; sr = <span class="keyword">new</span> SoftReference&lt;&gt;(buff);</span><br><span class="line">            list.add(sr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.gc(); <span class="comment">//主动通知垃圾回收</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">            Object obj = ((SoftReference) list.get(i)).get();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现无论循环创建多少个软引用对象，打印结果总是只有最后一个对象被保留，其他的obj全都被置空回收了。<br>这里就说明了在内存不足的情况下，软引用将会被自动回收。<br>值得注意的一点 , 即使有 byte[] buff 引用指向对象, 且 buff 是一个strong reference, 但是 SoftReference sr 指向的对象仍然被回收了，这是因为Java的编译器发现了在之后的代码中, buff 已经没有被使用了, 所以自动进行了优化。<br>如果我们将上面示例稍微修改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSoftReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buff = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; sr = <span class="keyword">new</span> SoftReference&lt;&gt;(buff);</span><br><span class="line">        list.add(sr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.gc(); <span class="comment">//主动通知垃圾回收</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">        Object obj = ((SoftReference) list.get(i)).get();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"buff: "</span> + buff.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则 buff 会因为强引用的存在，而无法被垃圾回收，从而抛出OOM的错误。</p>
<p>如果一个对象惟一剩下的引用是软引用，那么该对象是软可及的（softly reachable）。垃圾收集器并不像其收集弱可及的对象一样尽量地收集软可及的对象，相反，它只在真正 “需要” 内存时才收集软可及的对象。</p>
<p><strong>弱引用</strong></p>
<p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。<br>我们以与软引用同样的方式来测试一下弱引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        WeakReference&lt;<span class="keyword">byte</span>[]&gt; sr = <span class="keyword">new</span> WeakReference&lt;&gt;(buff);</span><br><span class="line">        list.add(sr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.gc(); <span class="comment">//主动通知垃圾回收</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">        Object obj = ((WeakReference) list.get(i)).get();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：全部为null</p>
<p>可以发现所有被弱引用关联的对象都被垃圾回收了。</p>
<p><strong>虚引用</strong></p>
<p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns this reference object's referent.  Because the referent of a</span></span><br><span class="line"><span class="comment">     * phantom reference is always inaccessible, this method always returns</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要作用是跟踪对象被垃圾回收的状态</p>
<h3 id="什么情况下判断需要调整新生带的大小"><a href="#什么情况下判断需要调整新生带的大小" class="headerlink" title="什么情况下判断需要调整新生带的大小"></a>什么情况下判断需要调整新生带的大小</h3><p>笨想一下,新生代最好每次minorGC最好大部分对象已经”死去”,这样对新生代采用的”复制清除算法”更有利.</p>
<h3 id="jvm的常见参数"><a href="#jvm的常见参数" class="headerlink" title="jvm的常见参数"></a>jvm的常见参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>-verbose:gc -XX:+printGC</td>
<td>打印GC的简要信息</td>
<td></td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>打印GC详细信息</td>
<td></td>
</tr>
<tr>
<td>-XX:+PrintGCTimeStamps</td>
<td>打印GC发生的时间戳</td>
<td></td>
</tr>
<tr>
<td>-Xlog:&lt;path&gt;</td>
<td>指定GClog的的位置,文件输出log</td>
<td></td>
</tr>
<tr>
<td>-XX:TraceClassLoading</td>
<td>监控类的的加载</td>
<td></td>
</tr>
<tr>
<td>-XX:+PrintClassHistogram</td>
<td>按下Ctr+Break后,打印类的信息</td>
<td></td>
</tr>
<tr>
<td>-Xmx -Xms</td>
<td>指定最大堆,最小堆</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>表示老年代:新生代的比值</td>
<td></td>
</tr>
<tr>
<td>-XX:SurivorRatio</td>
<td>eden:survivor的值</td>
<td></td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>OOM时导出堆到文件</td>
<td></td>
</tr>
<tr>
<td>-XX:+HeapDumpPath</td>
<td>导出OOM的路径</td>
<td></td>
</tr>
<tr>
<td>-Xss</td>
<td>设置栈的大小</td>
<td></td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>永久区的初始空间</td>
<td></td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>永久区的最大空间</td>
<td></td>
</tr>
<tr>
<td>-XX:OnOutOfMemoryError</td>
<td>在OOM时执行一个脚本</td>
<td></td>
</tr>
</tbody></table>
<h2 id="static-amp-final"><a href="#static-amp-final" class="headerlink" title="static &amp; final"></a>static &amp; final</h2><p>static:</p>
<ul>
<li>变量：类加载时被初始话，内存中只有一个;</li>
<li>方法：不能引用非static的方法或变量、必须实现;  </li>
<li>因为static是成员变量是gcRoot,不会随着该类new出来的对象回收而回收<br>static 变量在内存只有一个实体, 如下述代码中, 三个输出结果皆为2. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChildrenMySort.anInt=<span class="number">0</span>;</span><br><span class="line">        ChildrenMySort childrenMySort=<span class="keyword">new</span> ChildrenMySort();</span><br><span class="line">        ChildrenMySort childrenMySort2=<span class="keyword">new</span> ChildrenMySort();</span><br><span class="line">        childrenMySort.anInt=<span class="number">1</span>;</span><br><span class="line">        childrenMySort2.anInt=<span class="number">2</span>;</span><br><span class="line">        System.out.println(ChildrenMySort.anInt);</span><br><span class="line">        System.out.println(childrenMySort.anInt);</span><br><span class="line">        System.out.println(childrenMySort2.anInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
final ：</li>
<li>变量：类加载初始化，不可改变或引用不可变;</li>
<li>方法：不能被被子类重写;类：不能被继承;</li>
<li>形参：不能被子类修改;</li>
<li>final修饰的成员变量是gcroot 不会随改类定义的对象回收而回收;</li>
</ul>
<h3 id="hashtable、hashmap、currenthashmap"><a href="#hashtable、hashmap、currenthashmap" class="headerlink" title="hashtable、hashmap、currenthashmap:"></a>hashtable、hashmap、currenthashmap:</h3><p>线程安全：table安全，current安全而且效率更高，因为划分粒度更小，将哈希桶分段加锁;map不线程安全<br>null：table不允许空值，map允许，key和value都包括;<br>遍历：table使用枚举类，map使用迭代类<br>父类：table是Dictionary类，map继承AbstractMap<br>哈希值使用：table直接使用hashcode，map对hashcode在hash()<br>map的初始容量16 转化因子0.75</p>
<p>String +String 实际转化成stringbuild 的append（）</p>
<h3 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h3><p>TODO<br>将对象转化成字节序列，java远程调用，javabean。序列化内容：类名、属性，static属性不序列化、方法不序列化;反序列花：需要对应的class文件，实现ExternalSerialble的会调用构造方法，seriable不会;transient关键字修饰不必序列花的属性。</p>
<h3 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h3><p>TODO<br>三种方式：<br>继承Thread类，重写run函数<br>runable接口<br>callable接口 有返回值<br>线程安全：<br>volitate<br>synchronized<br>lock</p>
<p>线程池：</p>
<p>java内存泄露与溢出</p>
<h1 id="二-数据库知识"><a href="#二-数据库知识" class="headerlink" title="二. 数据库知识"></a>二. 数据库知识</h1><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>原子性：保证事务中的所有操作全部或全部不执行</p>
<p>一致性： 保持系统处于一致的状态</p>
<p>隔离性： 多事务并发执行 ，结果与多个事务串行效果一致</p>
<p>持久性：事物务操作后，对数据库的影响是持久的，即使数据库因故障而受到破坏。</p>
<h4 id="脏读、不可重复读、幻读"><a href="#脏读、不可重复读、幻读" class="headerlink" title="脏读、不可重复读、幻读"></a>脏读、不可重复读、幻读</h4><p>脏读：T1更新了一行记录的内容、但是没有提交、T2读取更新的行，然后T1回滚，T2就无效了。</p>
<p>不可重复读：T1读取一行，T2修改该行，T1又再次读取这行，发现与读取的结果不同</p>
<p>幻读：T1根据条件索引到N条数据，T2增添了M条数据，T1再次搜索发现幻读</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h4 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h4><p>m非事务安全，i事务安全</p>
<p>m粒度表级，i行级</p>
<p>m支持全文类型索引，而I不支持</p>
<p>m相对简单，效率高，适合小型应用</p>
<p>m表保存为文件格式，数据转移简单</p>
<p>i更安全</p>
<p>m适合查询，i适合修改</p>
<h5 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h5><p>select * from table limit m offset n;</p>
<h1 id="三-计算机网络知识"><a href="#三-计算机网络知识" class="headerlink" title="三. 计算机网络知识"></a>三. 计算机网络知识</h1><h2 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h2><p>语法、语义、时序</p>
<p>DNS 查询：迭代、递归</p>
<p>格式：（name,value,type,type,ttl）</p>
<p>Type=A name 主机域名 value Ip地址</p>
<p>Ns  域 该域权威域名解析服务器的主机域名</p>
<p>chame 真实域名的别名 真实域名</p>
<p>MX valueiname相对应的邮件服务器</p>
<h2 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h2><p>http-TCP 80 </p>
<p>https-SSL/TLS-TCP 443 需要证书，一般收费</p>
<h2 id="TCP可靠传输-amp-三次握手-amp-四此挥手"><a href="#TCP可靠传输-amp-三次握手-amp-四此挥手" class="headerlink" title="TCP可靠传输&amp;三次握手&amp;四此挥手"></a>TCP可靠传输&amp;三次握手&amp;四此挥手</h2><p>可靠：数据包校验、超时重传、流量控制 </p>
<p>三次：c反送SYN包 x 、s发送SYN ACK ack=x+1 编号 y 、c发送ACK  ack=y+1</p>
<p>四次：c发送FIN 编号m 、s发送ack m+1 、s发送FIN n、c发送ack n+1</p>
<h2 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h2><p>一直握2次手，不握第三次</p>
<h2 id="GET-amp-POST"><a href="#GET-amp-POST" class="headerlink" title="GET&amp;POST"></a>GET&amp;POST</h2><p>三get：数据小，不能发大量数据，请求不安全，幂等，</p>
<p>post：不能被缓存、安全、稳定可靠、数据量无限制</p>
<h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h3 id="6-网络层"><a href="#6-网络层" class="headerlink" title="6. 网络层"></a>6. 网络层</h3><p>核心功能: 转发与路由</p>
<h3 id="7-数据链路层"><a href="#7-数据链路层" class="headerlink" title="7. 数据链路层"></a>7. 数据链路层</h3><p>负责通过一条链路从一个节点向另一个物理链路直接相连的相邻节点传送数据报<br>功能:</p>
<ul>
<li>组帧</li>
<li>链路接入,在共享介质中需要信道接入</li>
<li>可靠交付,有线链路很少采用,无线链路误码率高故需采用</li>
<li>流量控制</li>
<li>差错检测 接收端通知重传或直接丢弃</li>
<li>差错纠正 接收端直接纠正</li>
</ul>
<table>
<thead>
<tr>
<th>发送端</th>
<th>接收端</th>
</tr>
</thead>
<tbody><tr>
<td>将数据封装成帧</td>
<td>提取数据报,交付上层协议</td>
</tr>
<tr>
<td>增加差错检测</td>
<td>检测差错,实现可靠数据传输和流量控制</td>
</tr>
</tbody></table>
<h4 id="7-1-多路访问控制协议MAC"><a href="#7-1-多路访问控制协议MAC" class="headerlink" title="7.1 多路访问控制协议MAC"></a>7.1 多路访问控制协议MAC</h4><p>点对点链路: </p>
<ul>
<li>拨号的PPP</li>
<li>以太网交换机与主机  </li>
</ul>
<p>广播链路:</p>
<ul>
<li>802.11无线局域网</li>
</ul>
<p>MAC三大类:</p>
<ul>
<li><p>信道划分</p>
<blockquote>
<p>多路复用,TDMA,FDMA,CDMA,WDMA</p>
</blockquote>
</li>
<li><p>随机访问</p>
<blockquote>
<p>允许冲突,冲突恢复机制</p>
</blockquote>
</li>
<li><p>轮转</p>
<blockquote>
<p>轮流使用</p>
</blockquote>
<h4 id="7-2-ARP协议"><a href="#7-2-ARP协议" class="headerlink" title="7.2 ARP协议"></a>7.2 ARP协议</h4></li>
</ul>
<h2 id="TCP快速重传"><a href="#TCP快速重传" class="headerlink" title="TCP快速重传"></a>TCP快速重传</h2><p>连续收到三个相同的ACK就直接重传</p>
<h2 id="5类ip地址"><a href="#5类ip地址" class="headerlink" title="5类ip地址"></a>5类ip地址</h2><table>
<thead>
<tr>
<th>类型</th>
<th>组成</th>
<th>范围</th>
<th>备注</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>1字节的网络地址3字节的主机地址</td>
<td>1.0.0.0~127.0.0.0</td>
<td>最高位为0,为大型网络设计</td>
<td>127.0.0.1表示主机本身</td>
</tr>
<tr>
<td>B</td>
<td>2字节网络2字节主机</td>
<td>128.0.0.0~191.255.255.255</td>
<td>网络地址最高为为10</td>
<td>其中128.0.0.0和191.255.0.0为保留ip，实际范围是128.1.0.0–191.254.0.0</td>
</tr>
<tr>
<td>C</td>
<td>3字节网络地址1字节主机地址</td>
<td>192.0.0.0~223.255.255.255</td>
<td>最高位110</td>
<td>其中192.0.0.0和223.255.255.0为保留ip，实际范围是192.0.1.0–223.255.254.0</td>
</tr>
<tr>
<td>D</td>
<td>多点广播</td>
<td>224.0.0~239.255.255.255</td>
<td>最高位1110</td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>保留地址</td>
<td>240.0.0.0~255.255.255.254</td>
<td>最高11110</td>
<td>255.255.255.255用于广播</td>
</tr>
</tbody></table>
<ul>
<li>0.0.0.0 对应当前主机</li>
<li></li>
</ul>
<h2 id="剑指off"><a href="#剑指off" class="headerlink" title="剑指off"></a>剑指off</h2><p>不确定问题大胆提问</p>
<p>自我介绍：30到60秒，主要学习经历</p>
<p>项目介绍：简短的项目背景、详细自己完成的任务、详细自己怎么完成的、自己的贡献</p>
<p>了解、熟悉、精通</p>
<p>重点算法：二分查找、归并排序、快速排序、动态规划、贪心算法</p>
<p>简单程序要有健壮性，考虑特殊情况</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8A%9D%E5%A3%AB/" rel="tag">芝士</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020
        <i class="ri-heart-fill heart_icon"></i> yzqaq
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="yzqaq"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/05/26/about/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['且将新火试新茶，诗酒趁年华', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
</body>

</html>